!_TAG_FILE_ENCODING	cp932	//
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_JP_AUTHOR	HIGASHI Hirohito	/Twitter: @h_east/
!_TAG_PROGRAM_JP_URL	http://hp.vector.co.jp/authors/VA025040/	//
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8J2	//
A	.\asset\base.cpp	/^	A() { printf("%08X%s:cons\\n", this, __FUNCTION__); }$/;"	f	class:A
A	.\asset\base.cpp	/^class A : public Base {$/;"	c	file:
A	.\asset\data.cpp	/^	A() {$/;"	f	struct:A
A	.\asset\data.cpp	/^struct A : public DataBase {$/;"	s	file:
ACTOR	.\asset\node.cpp	/^	ACTOR$/;"	e	enum:__anon1	file:
ACTOR_BG	.\asset\node.cpp	/^	ACTOR_BG:$/;"	e	enum:__anon1	file:
ACTOR_BULLET	.\asset\node.cpp	/^	ACTOR_BULLET,$/;"	e	enum:__anon1	file:
ACTOR_ENEMY	.\asset\node.cpp	/^	ACTOR_ENEMY,$/;"	e	enum:__anon1	file:
ACTOR_PLAYER	.\asset\node.cpp	/^	ACTOR_PLAYER,$/;"	e	enum:__anon1	file:
ACTOR_SYSTEM	.\asset\node.cpp	/^	ACTOR_SYSTEM = 0,$/;"	e	enum:__anon1	file:
ADSAMPLES	.\res\frect.cpp	4;"	d	file:
AO_ATTE	.\res\frect.cpp	7;"	d	file:
AO_REP	.\res\frect.cpp	1;"	d	file:
Actor	.\asset\map.cpp	/^	Actor() { }$/;"	f	class:Actor
Actor	.\asset\map.cpp	/^class Actor : public Node {$/;"	c	file:
Actor	.\asset\node.cpp	/^	Actor() { printf("%s\\n", __FUNCTION__); }$/;"	f	class:Actor
Actor	.\asset\node.cpp	/^class Actor : public Node {$/;"	c	file:
ActorCreate	.\asset\node.cpp	/^Actor *ActorCreate(int num) {$/;"	f
AddLog	.\util.cpp	/^void AddLog(const char *data) {$/;"	f
AddNode	.\asset\map.cpp	/^	void AddNode(const char *name,  Node *node) {$/;"	f	class:SceneManager
At	.\util.h	/^	vec  Pos, At, Up;$/;"	m	struct:Camera
B	.\asset\base.cpp	/^	B() { printf("%08X%s:cons\\n", this, __FUNCTION__); }$/;"	f	class:B
B	.\asset\base.cpp	/^class B : public Base {$/;"	c	file:
B	.\asset\data.cpp	/^	B() {$/;"	f	struct:B
B	.\asset\data.cpp	/^struct B : public DataBase {$/;"	s	file:
Base	.\asset\base.cpp	/^	Base() { printf("%08X%s:cons\\n", this, __FUNCTION__); }$/;"	f	class:Base
Base	.\asset\base.cpp	/^class Base {$/;"	c	file:
Begin	.\util.h	/^	void Begin() {$/;"	f	struct:RenderTarget
Bind	.\util.h	/^	void Bind() {$/;"	f	struct:Mesh
Bind	.\util.h	/^	void Bind() {$/;"	f	struct:Texture3D
BoundingBox	.\util.h	/^struct BoundingBox {$/;"	s
Buf	.\util.h	/^	unsigned char *Buf()  { return &buf[0]; }$/;"	f	struct:File
Bullet	.\asset\node.cpp	/^	Bullet() { printf("%s\\n", __FUNCTION__); }$/;"	f	class:Bullet
Bullet	.\asset\node.cpp	/^class Bullet : public Actor {$/;"	c	file:
C	.\asset\data.cpp	/^	C() {$/;"	f	struct:C
C	.\asset\data.cpp	/^struct C : public DataBase {$/;"	s	file:
Camera	.\util.h	/^struct Camera {$/;"	s
Clear	.\util.h	/^	void Clear() {$/;"	f	struct:File
Create	.\util.h	/^	void Create(float *v, int vnum, float *n, int nnum) {$/;"	f	struct:Mesh
Create	.\util.h	/^	void Create(int rect = 0, float *d = NULL) {$/;"	f	struct:Texture3D
Create	.\util.h	/^	void Create(int w, int h, int ms = 8) {$/;"	f	struct:RenderTarget
DEBUG	.\asset\map.cpp	17;"	d	file:
DEFAULT_HEIGHT	.\util.h	28;"	d
DEFAULT_WIDTH	.\util.h	27;"	d
DataBase	.\asset\data.cpp	/^	DataBase() {$/;"	f	struct:DataBase
DataBase	.\asset\data.cpp	/^struct DataBase {$/;"	s	file:
Del	.\asset\map.cpp	/^	void Del()        { delete this;   }$/;"	f	class:Node
Draw	.\asset\map.cpp	/^	virtual void Draw() {$/;"	f	class:Actor
Draw	.\asset\map.cpp	/^	virtual void Draw(){}$/;"	f	class:Node
Draw	.\asset\map.cpp	/^	void Draw() {$/;"	f	class:SceneManager
Draw	.\asset\node.cpp	/^	virtual void Draw()                 {}$/;"	f	class:Node
Draw	.\util.h	/^	void Draw() {$/;"	f	struct:Mesh
Empty	.\util.h	/^	bool Empty() { return buf.empty(); }$/;"	f	struct:File
End	.\util.h	/^	void End() {$/;"	f	struct:RenderTarget
Enemy	.\asset\node.cpp	/^	Enemy() { printf("%s\\n", __FUNCTION__); }$/;"	f	class:Enemy
Enemy	.\asset\node.cpp	/^class Enemy : public Bullet {$/;"	c	file:
FUNC_CHECK	.\asset\data.cpp	7;"	d	file:
File	.\util.h	/^struct File {$/;"	s
Fire	.\asset\node.cpp	/^	void Fire() {$/;"	f	class:Bullet
FuncSort	.\asset\map.cpp	/^bool FuncSort(Node *a, Node *b) {$/;"	f
GL_DEBUG1	.\util.h	31;"	d
GL_DEBUG2	.\util.h	32;"	d
GL_DEBUG3	.\util.h	33;"	d
GetChild	.\asset\node.cpp	/^	Node* GetChild()                    { return child; }$/;"	f	class:Node
GetDepth	.\res\frect.cpp	/^float GetDepth(float d) {$/;"	f
GetId	.\asset\map.cpp	/^	int  GetId()      { return id;     }$/;"	f	class:Node
GetName	.\asset\node.cpp	/^	const char* GetName()               { return name.c_str(); }$/;"	f	class:Node
GetNext	.\asset\map.cpp	/^	Node *GetNext()   { return next;   }$/;"	f	class:Node
GetParam	.\util.h	/^	void GetParam(float *p) {$/;"	f	struct:BoundingBox
GetParent	.\asset\node.cpp	/^	void GetParent()$/;"	f	class:Bullet
GetProj	.\util.h	/^	float *GetProj() { return (float *)&proj; }$/;"	f	struct:Camera
GetRoot	.\asset\node.cpp	/^	Node *GetRoot() { return Node::GetRoot(); }$/;"	f	class:NodeManager
GetRoot	.\asset\node.cpp	/^	Node *GetRoot() {$/;"	f	class:Node
GetType	.\asset\data.cpp	/^	int GetType() {$/;"	f	struct:DataBase
GetView	.\util.h	/^	float *GetView() { return (float *)&view; }$/;"	f	struct:Camera
Height	.\util.cpp	/^int   Height        = DEFAULT_HEIGHT;$/;"	v
Height	.\util.h	/^	int Width, Height, Sample;$/;"	m	struct:RenderTarget
Height	.\util.h	/^	int Width, Height;$/;"	m	struct:Camera
Ident	.\util.h	/^	float *Ident() {$/;"	f	struct:Matrix
IncColor	.\res\grect.cpp	/^in  vec4 IncColor[MAX_VERTEX];$/;"	v
IncColor	.\res\vvs.cpp	/^varying   vec4 IncColor;$/;"	v
IngColor	.\res\grect.cpp	/^in  vec4 IngColor[MAX_VERTEX];$/;"	v
IngColor	.\res\vvs.cpp	/^varying   vec4 IngColor;$/;"	v
Init	.\util.cpp	/^int Init(int argc, char *argv[], void (*StartMain)(int argc, char *argv[], HDC hdc)) {$/;"	f
Init	.\util.h	/^	void Init() {$/;"	f	struct:BoundingBox
Init	.\util.h	/^	void Init() {$/;"	f	struct:Mesh
IsHit	.\asset\node.cpp	/^	int IsHit() { return 0; }$/;"	f	class:Bullet
Line	.\util.h	/^	char *Line(const char c = '\\n') {$/;"	f	struct:File
Load	.\util.h	/^	int Load(const char *name) {$/;"	f	struct:OBJBlob
Load	.\util.h	/^	int Load(const char *name) {$/;"	f	struct:STLBlob
Load	.\util.h	/^	void Load(const char *name) {$/;"	f	struct:Mesh
LookAt	.\util.h	/^	float *LookAt(float *eye, float *center, float *up) {$/;"	f	struct:Matrix
LookAt	.\util.h	/^	float *LookAt(vec &eye, vec &center, vec &up) {$/;"	f	struct:Matrix
MAX_VERTEX	.\res\grect.cpp	3;"	d	file:
Matrix	.\util.h	/^struct Matrix {$/;"	s
Max	.\util.h	/^		Max = 99999999$/;"	e	enum:BoundingBox::__anon4
Max	.\util.h	/^		Max,$/;"	e	enum:Mesh::__anon5
Mesh	.\util.h	/^struct Mesh {$/;"	s
Move	.\asset\map.cpp	/^	virtual void Move() {$/;"	f	class:Actor
Move	.\asset\map.cpp	/^	virtual void Move(){}$/;"	f	class:Node
Move	.\asset\map.cpp	/^	void Move() {$/;"	f	class:SceneManager
Node	.\asset\map.cpp	/^	Node() {$/;"	f	class:Node
Node	.\asset\map.cpp	/^class Node {$/;"	c	file:
Node	.\asset\node.cpp	/^	Node() {$/;"	f	class:Node
Node	.\asset\node.cpp	/^class Node {$/;"	c	file:
NodeManager	.\asset\node.cpp	/^	NodeManager() {}$/;"	f	class:NodeManager
NodeManager	.\asset\node.cpp	/^class NodeManager : public Node {$/;"	c	file:
Normal	.\util.h	/^		Normal,$/;"	e	enum:Mesh::__anon5
OBJBlob	.\util.h	/^struct OBJBlob {$/;"	s
Open	.\util.h	/^	int Open(const char *name, bool il) {$/;"	f	struct:File
PACKET_MAX	.\asset\da.cpp	7;"	d	file:
PI	.\res\frect.cpp	3;"	d	file:
PI	.\util.h	100;"	d
Perspective	.\util.h	/^	float *Perspective(float fovy, float aspect, float fnear, float ffar) {$/;"	f	struct:Matrix
Player	.\asset\node.cpp	/^	Player() { printf("%s\\n", __FUNCTION__); }$/;"	f	class:Player
Player	.\asset\node.cpp	/^class Player : public Bullet {$/;"	c	file:
Pos	.\util.h	/^	vec  Pos, At, Up;$/;"	m	struct:Camera
PosEnd	.\util.h	/^	vec  PosEnd;$/;"	m	struct:Camera
PosStart	.\util.h	/^	vec  PosStart;$/;"	m	struct:Camera
Print	.\asset\node.cpp	/^	void Print()                        { printf("NAME = %s\\n", name.c_str()); }$/;"	f	class:Node
Print	.\util.h	/^		void Print() {$/;"	f	struct:STLBlob::stldata
Print	.\util.h	/^	void Print() {$/;"	f	struct:BoundingBox
Print	.\util.h	/^	void Print() {$/;"	f	struct:Matrix
ProcMsg	.\util.cpp	/^BOOL ProcMsg() {$/;"	f
RADIUS	.\res\frect.cpp	5;"	d	file:
RADIUS_MULT	.\res\frect.cpp	6;"	d	file:
RenderTarget	.\util.h	/^struct RenderTarget {$/;"	s
Reset	.\util.h	/^	void Reset() { state = 0; tt    = 0; }$/;"	f	struct:Camera
ResetShader	.\main.cpp	/^void ResetShader() {$/;"	f
Resolve	.\util.h	/^	void Resolve() {$/;"	f	struct:RenderTarget
RotX	.\util.h	/^	float *RotX(float a) {$/;"	f	struct:Matrix
RotY	.\util.h	/^	float *RotY(float a) {$/;"	f	struct:Matrix
RotZ	.\util.h	/^	float *RotZ(float a) {$/;"	f	struct:Matrix
SAMPLES	.\res\frect.cpp	2;"	d	file:
STLBlob	.\util.h	/^struct STLBlob {$/;"	s
STRONG	.\res\frect.cpp	8;"	d	file:
Sample	.\util.h	/^	int Width, Height, Sample;$/;"	m	struct:RenderTarget
Scale	.\util.h	/^	float *Scale(float x, float y, float z) {$/;"	f	struct:Matrix
SceneManager	.\asset\map.cpp	/^class SceneManager {$/;"	c	file:
SetChild	.\asset\node.cpp	/^	Node* SetChild(Node *nd)            { return child = nd; }$/;"	f	class:Node
SetId	.\asset\map.cpp	/^	int  SetId(int i) { return id = i; }$/;"	f	class:Node
SetName	.\asset\node.cpp	/^	std::string& SetName(const char *s) { return name = s; }$/;"	f	class:Node
SetProj	.\util.h	/^	void SetProj(float fov, float fn, float ff) { ffov = fov, fnear = fn, ffar = ff; }$/;"	f	struct:Camera
SetScreen	.\util.h	/^	void SetScreen(int w, int h) {$/;"	f	struct:Camera
SetShader	.\util.h	/^	void SetShader(int p) {$/;"	f	struct:Mesh
SetTexture	.\util.h	/^	void SetTexture() {$/;"	f	struct:RenderTarget
SetTracking	.\util.h	/^	void SetTracking(vec &p, float dt, int ty = 0) {$/;"	f	struct:Camera
SetType	.\asset\data.cpp	/^	void SetType(int a) {$/;"	f	struct:DataBase
SetView	.\util.h	/^	void SetView(vec &p, vec &a, vec &u) {$/;"	f	struct:Camera
Size	.\util.h	/^	int Size()   { return buf.size(); }$/;"	f	struct:File
StartMain	.\main.cpp	/^void StartMain(int argc, char *argv[], HDC hdc) {$/;"	f
Term	.\asset\node.cpp	/^	void Term()$/;"	f	class:Bullet
Texture3D	.\util.h	/^struct Texture3D {$/;"	s
Trans	.\util.h	/^	float *Trans(float x, float y, float z) {$/;"	f	struct:Matrix
Unbind	.\util.h	/^	void Unbind() {$/;"	f	struct:Mesh
Unbind	.\util.h	/^	void Unbind() {$/;"	f	struct:Texture3D
UnsetTexture	.\util.h	/^	void UnsetTexture() {$/;"	f	struct:RenderTarget
Up	.\util.h	/^	vec  Pos, At, Up;$/;"	m	struct:Camera
Update	.\asset\base.cpp	/^	virtual void Update() {}$/;"	f	class:Base
Update	.\asset\base.cpp	/^	void Update() { printf("%08X:%s:Update\\n", this, __FUNCTION__); }$/;"	f	class:A
Update	.\asset\base.cpp	/^	void Update() { printf("%08X:%s:Update\\n", this, __FUNCTION__); }$/;"	f	class:B
Update	.\asset\data.cpp	/^	void Update() {$/;"	f	struct:A
Update	.\asset\data.cpp	/^	void Update() {$/;"	f	struct:B
Update	.\asset\data.cpp	/^	void Update() {$/;"	f	struct:C
Update	.\asset\node.cpp	/^	virtual void Update()               {}$/;"	f	class:Node
Update	.\util.h	/^	void Update() {$/;"	f	struct:Camera
Us	.\asset\node.cpp	/^	void Us()$/;"	f	class:Bullet
Vertex	.\util.h	/^		Vertex = 0,$/;"	e	enum:Mesh::__anon5
Width	.\util.cpp	/^int   Width         = DEFAULT_WIDTH;$/;"	v
Width	.\util.h	/^	int Width, Height, Sample;$/;"	m	struct:RenderTarget
Width	.\util.h	/^	int Width, Height;$/;"	m	struct:Camera
WindowProc	.\util.cpp	/^LRESULT WINAPI WindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {$/;"	f
Windowed	.\util.cpp	/^BOOL  Windowed      = TRUE;$/;"	v
_UTIL_H_	.\util.h	5;"	d
_VEC3_DEFOP_	.\util.h	132;"	d
a	.\util.cpp	/^static int a = 1, b = 234567, c = 890123;$/;"	v	file:
b	.\util.cpp	/^static int a = 1, b = 234567, c = 890123;$/;"	v	file:
bb	.\util.h	/^	BoundingBox bb;$/;"	m	struct:Mesh
bb	.\util.h	/^	BoundingBox bb;$/;"	m	struct:STLBlob
bmax	.\util.h	/^	float bmax[3];$/;"	m	struct:BoundingBox
bmin	.\util.h	/^	float bmin[3];$/;"	m	struct:BoundingBox
buf	.\util.h	/^	std::vector<unsigned char>       buf;$/;"	m	struct:File
c	.\util.cpp	/^static int a = 1, b = 234567, c = 890123;$/;"	v	file:
cColor	.\res\grect.cpp	/^out vec4 cColor[MAX_VERTEX];$/;"	v
cColor	.\res\lvs.cpp	/^varying   vec4 cColor;$/;"	v
cColor	.\res\vblit.cpp	/^varying   vec4 cColor;$/;"	v
cColor	.\res\vfs.cpp	/^varying vec4 cColor;$/;"	v
cColor	.\res\vrect.cpp	/^varying   vec4 cColor;$/;"	v
chain	.\asset\node.cpp	/^	Node *chain;$/;"	m	class:Node	file:
child	.\asset\node.cpp	/^	Node *child;$/;"	m	class:Node	file:
clamp	.\util.h	/^inline float clamp(float x, float a, float b) {$/;"	f
cross	.\util.h	/^	vec cross(vec &a, vec &b) {$/;"	f	struct:vec
cross	.\util.h	/^	vec cross(vec &b) {$/;"	f	struct:vec
d2r	.\util.h	103;"	d
data	.\util.h	/^		float data[4];$/;"	m	union:vec::__anon2
data	.\util.h	/^	float data[16];$/;"	m	struct:Matrix
data_sort	.\asset\data.cpp	/^bool data_sort(DataBase *a, DataBase *b) {$/;"	f
data_sort_int	.\asset\data.cpp	/^bool data_sort_int(int a, int b) {$/;"	f
dot	.\util.h	/^	float dot() {$/;"	f	struct:vec
dot	.\util.h	/^	float dot(vec &a) {$/;"	f	struct:vec
dtt	.\util.h	/^	float dtt;$/;"	m	struct:Camera
fbo	.\util.h	/^	GLuint fbo;$/;"	m	struct:RenderTarget
fbo2	.\util.h	/^	GLuint fbo2;$/;"	m	struct:RenderTarget
ffar	.\util.h	/^	float ffov, fnear, ffar;$/;"	m	struct:Camera
ffov	.\util.h	/^	float ffov, fnear, ffar;$/;"	m	struct:Camera
fnear	.\util.h	/^	float ffov, fnear, ffar;$/;"	m	struct:Camera
frand	.\util.cpp	/^float frand() {$/;"	f
gColor	.\res\grect.cpp	/^out vec4 gColor[MAX_VERTEX];$/;"	v
gColor	.\res\lvs.cpp	/^varying   vec4 gColor;$/;"	v
gColor	.\res\vblit.cpp	/^varying   vec4 gColor;$/;"	v
gColor	.\res\vfs.cpp	/^varying vec4 gColor;$/;"	v
gColor	.\res\vrect.cpp	/^varying   vec4 gColor;$/;"	v
getao	.\res\frect.cpp	/^float getao(vec2 uv) {$/;"	f
getao2	.\res\frect.cpp	/^float getao2(vec2 uv) {$/;"	f
gid	.\asset\map.cpp	/^	static int   gid;$/;"	m	class:Node	file:
gid	.\asset\map.cpp	/^int Node::gid   = 1;$/;"	m	class:Node	file:
glActiveTexture	.\util.cpp	/^PFNGLACTIVETEXTUREPROC                  glActiveTexture             = NULL;$/;"	v
glAttachShader	.\util.cpp	/^PFNGLATTACHSHADERPROC                   glAttachShader              = NULL;$/;"	v
glBeginTransformFeedback	.\util.cpp	/^PFNGLBEGINTRANSFORMFEEDBACKPROC         glBeginTransformFeedback    = NULL;$/;"	v
glBindAttribLocation	.\util.cpp	/^PFNGLBINDATTRIBLOCATIONPROC             glBindAttribLocation        = NULL;$/;"	v
glBindBuffer	.\util.cpp	/^PFNGLBINDBUFFERPROC                     glBindBuffer                = NULL;$/;"	v
glBindBufferBase	.\util.cpp	/^PFNGLBINDBUFFERBASEPROC                 glBindBufferBase            = NULL;$/;"	v
glBindFramebuffer	.\util.cpp	/^PFNGLBINDFRAMEBUFFERPROC                glBindFramebuffer           = NULL;$/;"	v
glBindRenderBuffer	.\util.cpp	/^PFNGLBINDRENDERBUFFERPROC               glBindRenderBuffer          = NULL;$/;"	v
glBindVertexArray	.\util.cpp	/^PFNGLBINDVERTEXARRAYPROC                glBindVertexArray           = NULL;$/;"	v
glBlitFramebuffer	.\util.cpp	/^PFNGLBLITFRAMEBUFFERPROC                glBlitFramebuffer           = NULL;$/;"	v
glBufferData	.\util.cpp	/^PFNGLBUFFERDATAPROC                     glBufferData                = NULL;$/;"	v
glCheckFramebufferStatus	.\util.cpp	/^PFNGLCHECKFRAMEBUFFERSTATUSPROC         glCheckFramebufferStatus    = NULL;$/;"	v
glCompileShader	.\util.cpp	/^PFNGLCOMPILESHADERPROC                  glCompileShader             = NULL;$/;"	v
glCreateProgram	.\util.cpp	/^PFNGLCREATEPROGRAMPROC                  glCreateProgram             = NULL;$/;"	v
glCreateShader	.\util.cpp	/^PFNGLCREATESHADERPROC                   glCreateShader              = NULL;$/;"	v
glCreateShaderFromFile	.\util.cpp	/^static GLuint glCreateShaderFromFile(const char *fname, int type) {$/;"	f	file:
glDeleteBuffers	.\util.cpp	/^PFNGLDELETEBUFFERSPROC                  glDeleteBuffers             = NULL;$/;"	v
glDeleteShader	.\util.cpp	/^PFNGLDELETESHADERPROC                   glDeleteShader              = NULL;$/;"	v
glDisableVertexAttribArray	.\util.cpp	/^PFNGLDISABLEVERTEXATTRIBARRAYPROC       glDisableVertexAttribArray  = NULL;$/;"	v
glDrawBuffers	.\util.cpp	/^PFNGLDRAWBUFFERSPROC                    glDrawBuffers               = NULL;$/;"	v
glEnableVertexAttribArray	.\util.cpp	/^PFNGLENABLEVERTEXATTRIBARRAYPROC        glEnableVertexAttribArray   = NULL;$/;"	v
glEndTransformFeedback	.\util.cpp	/^PFNGLENDTRANSFORMFEEDBACKPROC           glEndTransformFeedback      = NULL;$/;"	v
glErrorCallbackUser	.\util.cpp	/^static void glErrorCallbackUser (GLenum source, GLenum type, GLuint id,$/;"	f	file:
glFramebufferRenderbuffer	.\util.cpp	/^PFNGLFRAMEBUFFERRENDERBUFFERPROC        glFramebufferRenderbuffer   = NULL;$/;"	v
glFramebufferTexture	.\util.cpp	/^PFNGLFRAMEBUFFERTEXTUREPROC             glFramebufferTexture        = NULL;$/;"	v
glFramebufferTexture2D	.\util.cpp	/^PFNGLFRAMEBUFFERTEXTURE2DPROC           glFramebufferTexture2D      = NULL;$/;"	v
glGenBuffers	.\util.cpp	/^PFNGLGENBUFFERSPROC                     glGenBuffers                = NULL;$/;"	v
glGenFramebuffers	.\util.cpp	/^PFNGLGENFRAMEBUFFERSPROC                glGenFramebuffers           = NULL;$/;"	v
glGenRenderBuffers	.\util.cpp	/^PFNGLGENRENDERBUFFERSPROC               glGenRenderBuffers          = NULL;$/;"	v
glGenVertexArrays	.\util.cpp	/^PFNGLGENVERTEXARRAYSPROC                glGenVertexArrays           = NULL;$/;"	v
glGenerateMipmap	.\util.cpp	/^PFNGLGENERATEMIPMAPPROC                 glGenerateMipmap            = NULL;$/;"	v
glGetAttribLocation	.\util.cpp	/^PFNGLGETATTRIBLOCATIONPROC              glGetAttribLocation         = NULL;$/;"	v
glGetBufferSubData	.\util.cpp	/^PFNGLGETBUFFERSUBDATAPROC               glGetBufferSubData          = NULL;$/;"	v
glGetProgramInfoLog	.\util.cpp	/^PFNGLGETPROGRAMINFOLOGPROC              glGetProgramInfoLog         = NULL;$/;"	v
glGetShaderInfoLog	.\util.cpp	/^PFNGLGETSHADERINFOLOGPROC               glGetShaderInfoLog          = NULL;$/;"	v
glGetUniformLocation	.\util.cpp	/^PFNGLGETUNIFORMLOCATIONPROC             glGetUniformLocation        = NULL;$/;"	v
glInitFunc	.\util.cpp	/^void glInitFunc() {$/;"	f
glLinkProgram	.\util.cpp	/^PFNGLLINKPROGRAMPROC                    glLinkProgram               = NULL;$/;"	v
glLoadShader	.\util.cpp	/^GLuint glLoadShader(const char *vsfile, const char *gsfile, const char *fsfile) {$/;"	f
glProgramUniform1i	.\util.cpp	/^PFNGLPROGRAMUNIFORM1IPROC               glProgramUniform1i          = NULL;$/;"	v
glRenderBufferStorage	.\util.cpp	/^PFNGLRENDERBUFFERSTORAGEPROC            glRenderBufferStorage       = NULL;$/;"	v
glRenderbufferStorageMultisample	.\util.cpp	/^PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC glRenderbufferStorageMultisample = NULL;$/;"	v
glSetInterval	.\util.cpp	/^void glSetInterval(int isinterval) {$/;"	f
glShaderSource	.\util.cpp	/^PFNGLSHADERSOURCEPROC                   glShaderSource              = NULL;$/;"	v
glTexImage2DMultisample	.\util.cpp	/^PFNGLTEXIMAGE2DMULTISAMPLEPROC          glTexImage2DMultisample     = NULL;$/;"	v
glTexImage3D	.\util.cpp	/^PFNGLTEXIMAGE3DPROC                     glTexImage3D                = NULL;$/;"	v
glTransformFeedbackVaryings	.\util.cpp	/^PFNGLTRANSFORMFEEDBACKVARYINGSPROC      glTransformFeedbackVaryings = NULL;$/;"	v
glUniform1f	.\util.cpp	/^PFNGLUNIFORM1FPROC                      glUniform1f                 = NULL;$/;"	v
glUniform1i	.\util.cpp	/^PFNGLUNIFORM1IPROC                      glUniform1i                 = NULL;$/;"	v
glUniform4fv	.\util.cpp	/^PFNGLUNIFORM4FVPROC                     glUniform4fv                = NULL;$/;"	v
glUniformMatrix4fv	.\util.cpp	/^PFNGLUNIFORMMATRIX4FVPROC               glUniformMatrix4fv          = NULL;$/;"	v
glUseProgram	.\util.cpp	/^PFNGLUSEPROGRAMPROC                     glUseProgram                = NULL;$/;"	v
glVertexAttribPointer	.\util.cpp	/^PFNGLVERTEXATTRIBPOINTERPROC            glVertexAttribPointer       = NULL;$/;"	v
id	.\asset\map.cpp	/^	int id;$/;"	m	class:Node	file:
info	.\asset\fblit.cpp	/^uniform vec4        info;$/;"	v
info	.\res\frect.cpp	/^uniform vec4        info;$/;"	v
info	.\res\lvs.cpp	/^uniform   vec4 info;$/;"	v
info	.\res\vfs.cpp	/^uniform vec4 info;$/;"	v
info	.\res\vvs.cpp	/^uniform   vec4 info;$/;"	v
info2	.\asset\fblit.cpp	/^uniform vec4        info2;$/;"	v
info2	.\res\frect.cpp	/^uniform vec4        info2;$/;"	v
length	.\util.h	/^	float length()	{$/;"	f	struct:vec
length	.\util.h	/^	float length(vec &a)	{$/;"	f	struct:vec
lerp	.\util.h	/^	vec lerp(vec &a, vec &b, float k) {$/;"	f	struct:vec
lerp	.\util.h	/^inline float lerp(float x, float y, float a) {$/;"	f
lerpc	.\util.h	/^	vec lerpc(vec &a, vec &b, float k) {$/;"	f	struct:vec
lerpc	.\util.h	/^inline float lerpc(float a, float b, float x) { $/;"	f
main	.\asset\base.cpp	/^int main() {$/;"	f
main	.\asset\da.cpp	/^int main() {$/;"	f
main	.\asset\data.cpp	/^int main()$/;"	f
main	.\asset\fblit.cpp	/^void main() {$/;"	f
main	.\asset\map.cpp	/^void main() {$/;"	f
main	.\asset\node.cpp	/^int main() {$/;"	f
main	.\asset\test.cpp	/^int main()$/;"	f
main	.\asset\token.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	.\main.cpp	/^int main(int argc, char *argv[]) { return Init(argc, argv, StartMain);}$/;"	f
main	.\res\frect.cpp	/^void main() {$/;"	f
main	.\res\grect.cpp	/^void main() {$/;"	f
main	.\res\lvs.cpp	/^void main() {$/;"	f
main	.\res\vblit.cpp	/^void main() {$/;"	f
main	.\res\vfs.cpp	/^void main() {$/;"	f
main	.\res\vrect.cpp	/^void main()$/;"	f
main	.\res\vvs.cpp	/^void main() {$/;"	f
mix	.\util.h	/^inline float mix(float x, float y, float a) {$/;"	f
n	.\util.h	/^		float n[3];$/;"	m	struct:STLBlob::stldata
name	.\asset\node.cpp	/^	std::string name;$/;"	m	class:Node	file:
next	.\asset\map.cpp	/^	Node *next;$/;"	m	class:Node	file:
normal	.\res\lvs.cpp	/^attribute vec3 normal;$/;"	v
normal	.\res\vvs.cpp	/^attribute vec3 normal;$/;"	v
normalize	.\util.h	/^	vec normalize() {$/;"	f	struct:vec
np	.\util.h	/^	std::vector<float> np;$/;"	m	struct:STLBlob
operator *	.\util.h	/^	Matrix operator * (const Matrix &x) {$/;"	f	struct:Matrix
p	.\util.h	/^		float p[9];$/;"	m	struct:STLBlob::stldata
position	.\res\lvs.cpp	/^attribute vec3 position;$/;"	v
position	.\res\vblit.cpp	/^attribute vec3 position;$/;"	v
position	.\res\vrect.cpp	/^attribute vec3 position;$/;"	v
position	.\res\vvs.cpp	/^attribute vec3 position;$/;"	v
print	.\util.h	/^	void print() {$/;"	f	struct:vec
proj	.\res\lvs.cpp	/^uniform   mat4 proj;$/;"	v
proj	.\res\vfs.cpp	/^uniform mat4 proj;$/;"	v
proj	.\res\vvs.cpp	/^uniform   mat4 proj;$/;"	v
proj	.\util.h	/^	Matrix proj;$/;"	m	struct:Camera
ptr	.\util.h	/^	char *ptr;$/;"	m	struct:File
random	.\util.cpp	/^int random() {$/;"	f
rbo	.\util.h	/^	GLuint rbo;$/;"	m	struct:RenderTarget
reserve	.\util.h	/^		unsigned short reserve;$/;"	m	struct:STLBlob::stldata
root	.\asset\map.cpp	/^	static Node *root;$/;"	m	class:Node	file:
root	.\asset\map.cpp	/^Node *Node::root = NULL;$/;"	m	class:Node	file:
root	.\asset\node.cpp	/^	static Node *root;$/;"	m	class:Node	file:
root	.\asset\node.cpp	/^Node *Node::root = 0;$/;"	m	class:Node	file:
rttex	.\util.h	/^	GLuint rttex;$/;"	m	struct:RenderTarget
rttex2	.\util.h	/^	GLuint rttex2;$/;"	m	struct:RenderTarget
sep	.\util.h	/^	std::vector<char>                sep;$/;"	m	struct:File
shader	.\main.cpp	/^GLuint shader      = 0;$/;"	v
shader	.\util.h	/^	GLint  shader;$/;"	m	struct:Mesh
shader_blit	.\main.cpp	/^GLuint shader_blit = 0;$/;"	v
shader_rect	.\main.cpp	/^GLuint shader_rect = 0;$/;"	v
show_fps	.\util.cpp	/^void show_fps() {$/;"	f
smoothstep	.\util.h	/^	vec smoothstep(vec &a, vec &b, float k) {$/;"	f	struct:vec
smoothstep	.\util.h	/^inline float smoothstep(float e0, float e1, float x) {$/;"	f
state	.\util.h	/^	int state;$/;"	m	struct:Camera
stldata	.\util.h	/^	struct stldata {$/;"	s	struct:STLBlob
tex	.\asset\fblit.cpp	/^uniform sampler2D   tex;$/;"	v
tex	.\res\frect.cpp	/^uniform sampler2D   tex;$/;"	v
tex	.\res\vblit.cpp	/^uniform   sampler2D   tex;$/;"	v
tex	.\res\vrect.cpp	/^uniform   sampler2D   tex;$/;"	v
tex3d	.\util.h	/^	GLuint tex3d;$/;"	m	struct:Texture3D
trinum	.\util.h	/^	int trinum;$/;"	m	struct:Mesh
tt	.\util.h	/^	float  tt;$/;"	m	struct:Camera
type	.\asset\data.cpp	/^	int type;$/;"	m	struct:DataBase	file:
vNodeMap	.\asset\map.cpp	/^	std::map<std::string, Node *> vNodeMap;$/;"	m	class:SceneManager	file:
vbo	.\util.h	/^	GLuint vbo[Max];$/;"	m	struct:Mesh
vdraw	.\asset\map.cpp	/^	std::vector<Node *> vdraw;$/;"	m	class:SceneManager	file:
vec	.\util.h	/^	vec() {$/;"	f	struct:vec
vec	.\util.h	/^	vec(float a) {$/;"	f	struct:vec
vec	.\util.h	/^	vec(float a, float b, float c) {$/;"	f	struct:vec
vec	.\util.h	/^	vec(float a, float b, float c, float d) {$/;"	f	struct:vec
vec	.\util.h	/^__declspec(align(256)) struct vec {$/;"	s
vertexnum	.\util.h	/^	int vertexnum;$/;"	m	struct:Mesh
vi	.\util.h	/^	std::vector<int>   vi;$/;"	m	struct:OBJBlob
view	.\res\lvs.cpp	/^uniform   mat4 view;$/;"	v
view	.\res\vfs.cpp	/^uniform mat4 view;$/;"	v
view	.\res\vvs.cpp	/^uniform   mat4 view;$/;"	v
view	.\util.h	/^	Matrix view;$/;"	m	struct:Camera
vmove	.\asset\map.cpp	/^	std::vector<Node *> vmove;$/;"	m	class:SceneManager	file:
vp	.\util.h	/^	std::vector<float> vp;$/;"	m	struct:OBJBlob
vp	.\util.h	/^	std::vector<float> vp;$/;"	m	struct:STLBlob
w	.\util.h	/^			float x, y, z, w;$/;"	m	struct:vec::__anon2::__anon3
world	.\res\lvs.cpp	/^uniform   mat4 world;$/;"	v
world	.\res\vfs.cpp	/^uniform mat4 world;$/;"	v
world	.\res\vvs.cpp	/^uniform   mat4 world;$/;"	v
x	.\util.h	/^			float x, y, z, w;$/;"	m	struct:vec::__anon2::__anon3
y	.\util.h	/^			float x, y, z, w;$/;"	m	struct:vec::__anon2::__anon3
z	.\util.h	/^			float x, y, z, w;$/;"	m	struct:vec::__anon2::__anon3
~A	.\asset\base.cpp	/^	~A() { printf("%08X:%s:dest\\n", this, __FUNCTION__); }$/;"	f	class:A
~A	.\asset\data.cpp	/^	virtual ~A() {$/;"	f	struct:A
~Actor	.\asset\map.cpp	/^	virtual ~Actor() { }$/;"	f	class:Actor
~Actor	.\asset\node.cpp	/^	virtual ~Actor() {}$/;"	f	class:Actor
~B	.\asset\base.cpp	/^	~B() { printf("%08X:%s:dest\\n", this, __FUNCTION__); }$/;"	f	class:B
~B	.\asset\data.cpp	/^	virtual ~B() {$/;"	f	struct:B
~Base	.\asset\base.cpp	/^	virtual ~Base() { printf("%08X:%s:dest\\n", this, __FUNCTION__); }$/;"	f	class:Base
~Bullet	.\asset\node.cpp	/^	virtual ~Bullet() {}$/;"	f	class:Bullet
~C	.\asset\data.cpp	/^	virtual ~C() {$/;"	f	struct:C
~DataBase	.\asset\data.cpp	/^	virtual ~DataBase() {$/;"	f	struct:DataBase
~Enemy	.\asset\node.cpp	/^	virtual ~Enemy() {}$/;"	f	class:Enemy
~Node	.\asset\map.cpp	/^	virtual ~Node(){}$/;"	f	class:Node
~Node	.\asset\node.cpp	/^	virtual ~Node()                     {}$/;"	f	class:Node
~NodeManager	.\asset\node.cpp	/^	virtual ~NodeManager() {}$/;"	f	class:NodeManager
~Player	.\asset\node.cpp	/^	virtual ~Player() {}$/;"	f	class:Player
